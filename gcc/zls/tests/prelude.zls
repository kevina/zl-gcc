# type decls
(talias FILE (struct _IO_FILE))
(talias size_t (unsigned-int))
(talias bool (int))
(talias EnvironSnapshot (struct EnvironSnapshot))
(talias Mark (struct Mark))
(.struct UnmarkedSyntax)
(.struct Syntax)
(.struct SyntaxList)
(.struct SyntaxEnum)
(.struct Match)
(talias Context (struct Context))
(talias Environ (struct Environ))
(.enum _s_0_)
(talias Position (enum _s_0_))
(.struct UserTypeInfo)
(.struct ModuleInfo)
# type definitions
(.enum _s_0_
   (NoPos 0)
   (OtherPos 1)
   (TopLevel 2)
   (FieldPos 4)
   (StmtDeclPos 8)
   (StmtPos 16)
   (ExpPos 32)
)
# macro sep. c. stuff
(var _macro_funs_size (unsigned) 1)
(var _macro_funs (.array (.ptr (char :const)) 1) (.
  (s "parse_class")
))
(var _syntaxes_size (unsigned) 74)
(.struct _syntaxes ((.ptr (char :const)) str) ((.ptr (struct UnmarkedSyntax)) syn))
(var _syntaxes (.array (struct _syntaxes) 74) (.
  (. (s "raw_syntax (name @ body :(public parent_n))") 0)
  (. (s "syntax name") 0)
  (. (s "syntax body") 0)
  (. (s "syntax parent_n") 0)
  (. (s "syntax {declare_user_type name;}") 0)
  (. (s "syntax _Data") 0)
  (. (s "syntax _Data") 0)
  (. (s "syntax parent") 0)
  (. (s "syntax parent") 0)
  (. (s "syntax _VTable") 0)
  (. (s "syntax _VTable") 0)
  (. (s "syntax _vtable") 0)
  (. (s "syntax _vtable") 0)
  (. (s "syntax _vptr") 0)
  (. (s "syntax _vptr") 0)
  (. (s "syntax _constructor") 0)
  (. (s "syntax _constructor") 0)
  (. (s "syntax _vtable_init") 0)
  (. (s "syntax _vtable_init") 0)
  (. (s "syntax parent_n::_VTable") 0)
  (. (s "syntax {parent_n parent;}") 0)
  (. (s "syntax {make_subtype parent_n class_cast_up;}") 0)
  (. (s "syntax {import parent_n;}") 0)
  (. (s "raw_syntax (declare_user_type (mid name))") 0)
  (. (s "raw_syntax ({...} @body)") 0)
  (. (s "syntax body") 0)
  (. (s "raw_syntax (what n @_)") 0)
  (. (s "syntax what") 0)
  (. (s "syntax n") 0)
  (. (s "syntax {class _VTable : public $1 {$2;};}") 0)
  (. (s "syntax {class _VTable {$1;};}") 0)
  (. (s "syntax {void _vtable_init(_VTable * _vt) {$1;} }") 0)
  (. (s "syntax _vtable_init") 0)
  (. (s "syntax {__static_constructor void init() {parent_n::_vtable_init(&_vtable); _vtable_init(&_vtable);}}") 0)
  (. (s "syntax {__static_constructor void init() {_vtable_init(&_vtable);}}") 0)
  (. (s "syntax {macro _vptr (:this this = this) {*(_VTable * *)&(((parent_n *)this)->_vptr);}}") 0)
  (. (s "raw_syntax (var (mid _vptr) (.ptr (mid _VTable)))") 0)
  (. (s "syntax _vptr") 0)
  (. (s "syntax {void _constructor() {_vptr = &_vtable;}}") 0)
  (. (s "syntax _constructor") 0)
  (. (s "syntax {class _VTable;}") 0)
  (. (s "syntax _VTable") 0)
  (. (s "syntax _VTable`outer") 0)
  (. (s "syntax {struct _Data {$1; $2;};}") 0)
  (. (s "syntax {finalize_user_type struct _Data;}") 0)
  (. (s "syntax {_VTable _vtable;}") 0)
  (. (s "syntax {export $1;}") 0)
  (. (s "syntax {user_type name {$1; $2;}}") 0)
  (. (s "raw_syntax (n @rest)") 0)
  (. (s "syntax static") 0)
  (. (s "raw_syntax(var (w/inner (mid n) internal) (mid rest))") 0)
  (. (s "syntax {macro n () {n`internal;}}") 0)
  (. (s "syntax {macro n (:this this = this) {(*(name *)this)..n;}}") 0)
  (. (s "raw_syntax (n parms ret body)") 0)
  (. (s "raw_syntax (@parms)") 0)
  (. (s "syntax parms") 0)
  (. (s "syntax static") 0)
  (. (s "syntax virtual") 0)
  (. (s "syntax nv") 0)
  (. (s "syntax n`non_virtual") 0)
  (. (s "syntax nv") 0)
  (. (s "syntax n") 0)
  (. (s "raw_syntax ((.ptr (mid name)) (fluid this))") 0)
  (. (s "syntax ((name  *)this)") 0)
  (. (s "syntax parms") 0)
  (. (s "syntax (:this this = this)") 0)
  (. (s "raw_syntax (fun (w/inner (mid n) internal) (.(mid $1)) (mid ret) (mid body))") 0)
  (. (s "syntax {macro nv ($1) {n`internal($2);}}") 0)
  (. (s "syntax {macro n ($1) {(this->_vptr->n)($2);}}") 0)
  (. (s "syntax pfun") 0)
  (. (s "raw_syntax (.ptr (.fun (.(mid $1)) (mid ret)))") 0)
  (. (s "syntax n") 0)
  (. (s "raw_syntax (var (mid n) (mid pfun))") 0)
  (. (s "raw_syntax (assign (-> (id _vt) (id (mid n))) \n                                         (cast (mid pfun) (id (w/inner (mid n) internal))))") 0)
))

# function decls
(fun printf (. ((.ptr (char :const)) ) ...) (int))
(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
(fun new_mark_f (. ((.ptr (EnvironSnapshot)) )) (.ptr (Mark)))
(fun syntax_flag (. ((.ptr (struct Syntax)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct Syntax)))
(fun new_syntax_list (.) (.ptr (struct SyntaxList)))
(fun syntax_list_empty (. ((.ptr (struct SyntaxList :const)) )) (int))
(fun syntax_list_append (. ((.ptr (struct SyntaxList)) ) ((.ptr (struct Syntax)) )) (void))
(fun syntax_enum_next (. ((.ptr (struct SyntaxEnum)) )) (.ptr (struct Syntax)))
(fun match (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) pattern) ((.ptr (struct Syntax)) with)) (.ptr (struct Match)))
(fun match_args (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) pattern) ((.ptr (struct Syntax)) with)) (.ptr (struct Match)))
(fun match_local (. ((.ptr (struct Match)) ) ...) (.ptr (struct Match)))
(fun match_var (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct Syntax)))
(fun match_varl (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct SyntaxEnum)))
(fun replace (. ((.ptr (struct UnmarkedSyntax)) ) ((.ptr (struct Match)) ) ((.ptr (Mark)) )) (.ptr (struct Syntax)))
(fun get_context (. ((.ptr (struct Syntax)) )) (.ptr (Context)))
(fun replace_context (. ((.ptr (struct UnmarkedSyntax)) ) ((.ptr (Context)) )) (.ptr (struct Syntax)))
(fun partly_expand (. ((.ptr (struct Syntax)) ) ((Position) pos) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
(fun partly_expand_list (. ((.ptr (struct SyntaxEnum)) ) ((Position) pos) ((.ptr (Environ)) )) (.ptr (struct SyntaxEnum)))
(fun pre_parse (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
(fun reparse (. ((.ptr (struct Syntax)) ) ((.ptr (char :const)) ) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
(fun string_to_syntax (. ((.ptr (char :const)) str)) (.ptr (struct UnmarkedSyntax)))
(fun syntax_to_string (. ((.ptr (struct UnmarkedSyntax)) )) (.ptr (char :const)))
(fun dump_syntax (. ((.ptr (struct UnmarkedSyntax)) )) (void))
(fun user_type_info (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct UserTypeInfo)))
(fun user_type_module (. ((.ptr (struct UserTypeInfo)) )) (.ptr (struct ModuleInfo)))
(fun module_info (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct ModuleInfo)))
(fun module_symbols (. ((.ptr (struct ModuleInfo)) )) (.ptr (struct SyntaxEnum)))
(fun module_have_symbol (. ((.ptr (struct ModuleInfo)) ) ((.ptr (struct Syntax)) )) (bool))
(fun temp_environ (. ((.ptr (Environ)) )) (.ptr (Environ)))
(fun ct_value (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (size_t))
(fun error (. ((.ptr (struct Syntax)) ) ((.ptr (char :const)) ) ...) (.ptr (struct Syntax)))
(fun get_symbol_prop (. ((.ptr (struct Syntax)) sym) ((.ptr (struct Syntax)) prop) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
(fun symbol_exists (. ((.ptr (struct UnmarkedSyntax)) sym) ((.ptr (struct Syntax)) where) ((.ptr (Mark)) ) ((.ptr (Environ)) )) (int))
(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
(fun parse_class_var (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b)) (void))
(fun parse_class_fun (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b) ((.ptr (struct UserTypeInfo)) parent_vtable) ((.ptr (struct SyntaxList)) vtable_b) ((.ptr (struct SyntaxList)) vtable_i) ((.ptr (Environ)) env)) (void))
# definitions
(var parse_class$env_ss (.ptr (struct EnvironSnapshot)))
(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)) (block
  (var mark$1 (.ptr (Mark)) (call new_mark_f (. (id parse_class$env_ss))))
  (var m$1 (.ptr (struct Match)) (call match_args (. 0 (member (deref (plus _syntaxes 0)) syn) p)))
  (var name$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 1)) syn))))
  (var body$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 2)) syn))))
  (var parent_s$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 3)) syn))))
  (if (not body$1)
    (block
      (return (call replace (. (member (deref (plus _syntaxes 4)) syn) m$1 mark$1)))
    )
  )
  (var parent$1 (.ptr (struct UserTypeInfo)) (eif (cast (int) parent_s$1) (call user_type_info (. parent_s$1 env)) 0))
  (var context$1 (.ptr (Context)) (call get_context (. name$1)))
  (var parent_m$1 (.ptr (struct ModuleInfo)) 0)
  (var parent_vtable$1 (.ptr (struct UserTypeInfo)) 0)
  (var parent_vtable_n$1 (.ptr (struct Syntax)) 0)
  (var vtable$1 (.ptr (struct Syntax)) 0)
  (var struct_p$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var struct_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var module_p$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var module_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var vtable_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var vtable_i$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var exports$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 5)) syn) (call replace_context (. (member (deref (plus _syntaxes 6)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 7)) syn) (call replace_context (. (member (deref (plus _syntaxes 8)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 9)) syn) (call replace_context (. (member (deref (plus _syntaxes 10)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 11)) syn) (call replace_context (. (member (deref (plus _syntaxes 12)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 13)) syn) (call replace_context (. (member (deref (plus _syntaxes 14)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 15)) syn) (call replace_context (. (member (deref (plus _syntaxes 16)) syn) context$1)))))
  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 17)) syn) (call replace_context (. (member (deref (plus _syntaxes 18)) syn) context$1)))))
  (if (cast (int) parent$1)
    (block
      (assign parent_m$1 (call user_type_module (. parent$1)))
      (assign parent_vtable_n$1 (call replace (. (member (deref (plus _syntaxes 19)) syn) m$1 mark$1)))
      (assign parent_vtable$1 (call user_type_info (. parent_vtable_n$1 env)))
      (call syntax_list_append (. struct_p$1 (call replace (. (member (deref (plus _syntaxes 20)) syn) m$1 mark$1))))
      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 21)) syn) m$1 mark$1))))
      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 22)) syn) m$1 mark$1))))
      (var itr$1 (.ptr (struct SyntaxEnum)) (call module_symbols (. parent_m$1)))
      (var syn$1 (.ptr (struct Syntax)))
      (block
        (local_label break$1)
        (local_label continue$1)
      (label continue$1)
        (if (not (assign syn$1 (call syntax_enum_next (. itr$1))))
          (goto break$1)
        )
        (block
          (call syntax_list_append (. exports$1 syn$1))
        )
        (goto continue$1)
      (label break$1)
      )
    )
  )
  (var lenv$1 (.ptr (Environ)) (call temp_environ (. env)))
  (call pre_parse (. (call replace (. (member (deref (plus _syntaxes 23)) syn) m$1 mark$1)) lenv$1))
  (var itr$1 (.ptr (struct SyntaxEnum)) (call partly_expand_list (. (call match_varl (. (call match (. 0 (member (deref (plus _syntaxes 24)) syn) body$1)) (member (deref (plus _syntaxes 25)) syn))) FieldPos lenv$1)))
  (var member$1 (.ptr (struct Syntax)))
  (block
    (local_label break$1)
    (local_label continue$1)
  (label continue$1)
    (if (not (assign member$1 (call syntax_enum_next (. itr$1))))
      (goto break$1)
    )
    (block
      (var m0$1 (.ptr (struct Match)) (call match (. m$1 (member (deref (plus _syntaxes 26)) syn) member$1)))
      (var what$1 (.ptr (char :const)) (call syntax_to_string (. (cast (.ptr (struct UnmarkedSyntax)) (call match_var (. m0$1 (member (deref (plus _syntaxes 27)) syn)))))))
      (if (eq (call strcmp (. what$1 (s "label"))) 0)
        (goto continue$1)
      )
      (if (eq (call strcmp (. what$1 (s "var"))) 0)
        (call parse_class_var (. member$1 m$1 mark$1 struct_b$1 module_b$1))
        (if (eq (call strcmp (. what$1 (s "fun"))) 0)
          (call parse_class_fun (. member$1 m$1 mark$1 struct_b$1 module_b$1 parent_vtable$1 vtable_b$1 vtable_i$1 lenv$1))
          (call syntax_list_append (. module_p$1 (call pre_parse (. member$1 lenv$1))))
        )
      )
      (call syntax_list_append (. exports$1 (call match_var (. m0$1 (member (deref (plus _syntaxes 28)) syn)))))
    )
    (goto continue$1)
  (label break$1)
  )
  (var need_vtable$1 (bool :const) (not (call syntax_list_empty (. vtable_i$1))))
  (if need_vtable$1
    (block
      (if (cast (int) parent_vtable$1)
        (block
          (assign vtable$1 (call replace (. (member (deref (plus _syntaxes 29)) syn) (call match_local (. m$1 parent_vtable_n$1 vtable_b$1 0)) mark$1)))
        )
        (block
          (assign vtable$1 (call replace (. (member (deref (plus _syntaxes 30)) syn) (call match_local (. m$1 vtable_b$1 0)) mark$1)))
        )
      )
      (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 31)) syn) (call match_local (. m$1 vtable_i$1 0)) mark$1))))
      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 32)) syn) m$1 mark$1))))
      (if (cast (int) parent_vtable$1)
        (block
          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 33)) syn) m$1 mark$1))))
        )
        (block
          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 34)) syn) m$1 mark$1))))
        )
      )
      (if (cast (int) parent_vtable$1)
        (block
          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 35)) syn) m$1 mark$1))))
        )
        (block
          (var v$1 (.ptr (struct Syntax)) (call replace (. (member (deref (plus _syntaxes 36)) syn) m$1 mark$1)))
          (call parse_class_var (. v$1 m$1 mark$1 struct_p$1 module_b$1))
        )
      )
      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 37)) syn) m$1 mark$1))))
      (var f$1 (.ptr (struct Syntax)) (call partly_expand (. (call replace (. (member (deref (plus _syntaxes 38)) syn) m$1 mark$1)) FieldPos env)))
      (call parse_class_fun (. f$1 m$1 mark$1 struct_p$1 module_p$1 0 vtable_b$1 vtable_i$1 env))
      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 39)) syn) m$1 mark$1))))
    )
  )
  (if need_vtable$1
    (block
      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 40)) syn) m$1 mark$1))))
      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 41)) syn) m$1 mark$1))))
      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 42)) syn) m$1 mark$1))))
    )
  )
  (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 43)) syn) (call match_local (. m$1 struct_p$1 struct_b$1 0)) mark$1))))
  (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 44)) syn) m$1 mark$1))))
  (if need_vtable$1
    (block
      (call syntax_list_append (. module_p$1 vtable$1))
      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 45)) syn) m$1 mark$1))))
    )
  )
  (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 46)) syn) (call match_local (. m$1 exports$1 0)) mark$1))))
  (var module_$1 (.ptr (struct Syntax)) (call replace (. (member (deref (plus _syntaxes 47)) syn) (call match_local (. m$1 module_p$1 module_b$1 0)) mark$1)))
  (return module_$1)
)
)
(fun parse_class_var (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b)) (void) (block
  (assign m (call match_args (. m (member (deref (plus _syntaxes 48)) syn) p)))
  (var is_static$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 49)) syn)))))
  (if is_static$1
    (block
      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 50)) syn) m mark))))
      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 51)) syn) m mark))))
    )
    (block
      (call syntax_list_append (. struct_b p))
      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 52)) syn) m mark))))
    )
  )
)
)
(fun parse_class_fun (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b) ((.ptr (struct UserTypeInfo)) parent_vtable) ((.ptr (struct SyntaxList)) vtable_b) ((.ptr (struct SyntaxList)) vtable_i) ((.ptr (Environ)) env)) (void) (block
  (assign m (call match_args (. m (member (deref (plus _syntaxes 53)) syn) p)))
  (assign m (call match_args (. m (member (deref (plus _syntaxes 54)) syn) (call match_var (. m (member (deref (plus _syntaxes 55)) syn))))))
  (var is_static$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 56)) syn)))))
  (var is_virtual$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 57)) syn)))))
  (if is_virtual$1
    (assign m (call match (. m (member (deref (plus _syntaxes 58)) syn) (call replace (. (member (deref (plus _syntaxes 59)) syn) m mark)))))
    (assign m (call match (. m (member (deref (plus _syntaxes 60)) syn) (call replace (. (member (deref (plus _syntaxes 61)) syn) m mark)))))
  )
  (var new_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (if (not is_static$1)
    (call syntax_list_append (. new_parms$1 (call replace (. (member (deref (plus _syntaxes 62)) syn) m mark))))
  )
  (var macro_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (var call_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
  (if (not is_static$1)
    (call syntax_list_append (. call_parms$1 (call replace (. (member (deref (plus _syntaxes 63)) syn) m mark))))
  )
  (var parms_enum$1 (.ptr (struct SyntaxEnum)) (call match_varl (. m (member (deref (plus _syntaxes 64)) syn))))
  (var i$1 (unsigned-int) 0)
  (var parm$1 (.ptr (struct Syntax)))
  (block
    (local_label break$1)
    (local_label continue$1)
  (label continue$1)
    (if (not (assign parm$1 (call syntax_enum_next (. parms_enum$1))))
      (goto break$1)
    )
    (block
      (call syntax_list_append (. new_parms$1 parm$1))
      (var sbuf$1 (.array (char) 8))
      (call snprintf (. sbuf$1 (cast (size_t) 8) (s "arg%d") i$1))
      (var arg$1 (.ptr (struct Syntax)) (call replace (. (call string_to_syntax (. sbuf$1)) 0 mark)))
      (call syntax_list_append (. macro_parms$1 arg$1))
      (call syntax_list_append (. call_parms$1 arg$1))
      (c-assign plus i$1 (cast (unsigned-int) 1))
    )
    (goto continue$1)
  (label break$1)
  )
  (if (not is_static$1)
    (call syntax_list_append (. macro_parms$1 (call replace (. (member (deref (plus _syntaxes 65)) syn) m mark))))
  )
  (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 66)) syn) (call match_local (. m new_parms$1 0)) mark))))
  (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 67)) syn) (call match_local (. m macro_parms$1 call_parms$1 0)) mark))))
  (if is_virtual$1
    (block
      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 68)) syn) (call match_local (. m macro_parms$1 call_parms$1 0)) mark))))
      (assign m (call match (. m (member (deref (plus _syntaxes 69)) syn) (call replace (. (member (deref (plus _syntaxes 70)) syn) (call match_local (. m new_parms$1 0)) mark)))))
      (if (not (eif (cast (int) parent_vtable) (call module_have_symbol (. (call user_type_module (. parent_vtable)) (call match_var (. m (member (deref (plus _syntaxes 71)) syn))))) 0))
        (block
          (call syntax_list_append (. vtable_b (call replace (. (member (deref (plus _syntaxes 72)) syn) m mark))))
        )
      )
      (call syntax_list_append (. vtable_i (call replace (. (member (deref (plus _syntaxes 73)) syn) m mark))))
    )
  )
)
)
# special
# done
